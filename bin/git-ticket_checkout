#! /usr/bin/env rvm 2.1.1@default do ruby
require 'debugger'
require 'utility/executor'

class LoudLogger
  def log(msg);puts msg;end
  def log_error(msg)
    puts msg
  end
end

class QuietLogger
  def log(msg);end
  def log_error(msg)
    puts Dir.pwd
    puts msg
  end
end

class TicketCheckout
  def call
    ['/Sites/apps/*', '/Sites/gems/*'].map{|d| Dir.home + d }.each do |superdir|
      Dir[superdir].each do |dir|
        fork do
          Dir.chdir(dir) do
            switch_branch
          end
        end
      end
    end
    Process.waitall

    Executor.new(LoudLogger.new, 'git current_branches').call
  end

  def switch_branch
    if branch_exists?
      commit_changes
      checkout_branch
      reset_generated_commits
    end
  end

  def branch_exists?
    get_branch ? true : false
  end

  def get_branch
    get_branch_uncached
  end

  def get_branch_uncached
    branches = ex('git branch -r')
    verbatim_match = /^\s*origin\/(#{branch})\s*$/
    ticket_match = /^\s*origin\/(FY-#{branch}\w+)\s*$/

    match = (branches.match(verbatim_match) || branches.match(ticket_match))
    match ? match[1].to_s : false
  end

  def branch
    ARGV[0]
  end

  def commit_changes
    ex('git g')
    if !git_changes.empty?
      ex('git add -A')
      ex('git commit -m "generated by script, run \'reset HEAD~1\'"')
    end
  end

  def git_changes
    ex "git st --porcelain --untracked-files=no | tr -d ' '"
  end

  def checkout_branch
    ex("git checkout #{get_branch}")
  end

  def reset_generated_commits
    if last_commit_was_generated?
      ex('git reset HEAD~1')
    end
  end

  def last_commit_was_generated?
    commit = ex('git log -1 --oneline')
    commit.match(/generated.by.script/) ? true : false
  end

  def ex(cmd)
    Executor.new(QuietLogger.new, cmd).call
  end
end

TicketCheckout.new.call
